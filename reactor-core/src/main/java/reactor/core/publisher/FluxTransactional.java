/*
 * Copyright (c) 2011-2018 Pivotal Software Inc, All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package reactor.core.publisher;

import java.util.Objects;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
import java.util.function.Function;
import java.util.function.Supplier;

import org.reactivestreams.Publisher;
import org.reactivestreams.Subscription;
import reactor.core.CoreSubscriber;
import reactor.core.Exceptions;
import reactor.core.Fuseable;
import reactor.util.Logger;
import reactor.util.Loggers;
import reactor.util.annotation.Nullable;

/**
 * Uses a resource, generated by a supplier for each individual Subscriber,
 * while streaming the values from a
 * Publisher derived from the same resource and makes sure the resource is released
 * if the sequence terminates or the Subscriber cancels.
 * <p>
 * <p>
 * Eager resource cleanup happens just before the source termination and exceptions
 * raised by the cleanup Consumer may override the terminal even. Non-eager
 * cleanup will drop any exception.
 *
 * @param <T> the value type streamed
 * @param <S> the resource type
 *
 * @see <a href="https://github.com/reactor/reactive-streams-commons">Reactive-Streams-Commons</a>
 */
final class FluxTransactional<T, S> extends Flux<T> implements Fuseable, SourceProducer<T> {

	private static final Logger LOGGER = Loggers.getLogger(FluxTransactional.class);

	final Supplier<S>                                           resourceSupplier;
	final Function<? super S, ? extends Publisher<? extends T>> transactionClosure;
	final Function<? super S, ? extends Publisher<?>>           commit;
	final Function<? super S, ? extends Publisher<?>>           rollback;
	final boolean                                               rollbackOnCancel;

	FluxTransactional(Supplier<S> transactionalResourceSupplier,
			Function<? super S, ? extends Publisher<?>> commit,
			Function<? super S, ? extends Publisher<?>> rollback,
			Function<? super S, ? extends Publisher<? extends T>> transactionClosure,
			boolean rollbackOnCancel) {
		this.resourceSupplier = Objects.requireNonNull(transactionalResourceSupplier, "transactionalResourceSupplier");
		this.transactionClosure = Objects.requireNonNull(transactionClosure, "transactionClosure");
		this.commit = Objects.requireNonNull(commit, "commit");
		this.rollback = Objects.requireNonNull(rollback, "rollback");
		this.rollbackOnCancel = rollbackOnCancel;
	}

	@Override
	@SuppressWarnings("unchecked")
	public void subscribe(CoreSubscriber<? super T> actual) {
		S resource;

		try {
			resource = Objects.requireNonNull(resourceSupplier.get(),
					"The resourceSupplier returned a null value");
		}
		catch (Throwable e) {
			Operators.error(actual, Operators.onOperatorError(e, actual.currentContext()));
			return;
		}

		Publisher<? extends T> p;

		try {
			p = Objects.requireNonNull(transactionClosure.apply(resource),
					"The transactionClosure function returned a null value");
		}
		catch (Throwable e) {
			//TODO should a closure#apply error translate to a rollback? (for now it will)
			p = Mono.error(e);
		}

//		if (p instanceof Fuseable) {
//			from(p).subscribe(new TransactionalFuseableSubscriber<>(actual,
//					resource, commit, rollback));
//		}
//		else if (actual instanceof ConditionalSubscriber) {
//			from(p).subscribe(new TransactionalConditionalSubscriber<>((ConditionalSubscriber<? super T>) actual,
//					resource, commit, rollback));
//		}
//		else {
			from(p).subscribe(new TransactionalSubscriber<>(actual, resource,
					commit, rollback, rollbackOnCancel));
//		}
	}

	@Override
	public Object scanUnsafe(Attr key) {
		return null; //no particular key to be represented, still useful in hooks
	}

	static final class TransactionalSubscriber<T, S> implements InnerOperator<T, T>,
	                                                            QueueSubscription<T> {

		final CoreSubscriber<? super T>                   actual;
		final S                                           resource;
		final Function<? super S, ? extends Publisher<?>> commit;
		final Function<? super S, ? extends Publisher<?>> rollback;
		final boolean                                     rollbackOnCancel;

		volatile     Subscription s;
		static final AtomicReferenceFieldUpdater<TransactionalSubscriber, Subscription> SUBSCRIPTION =
				AtomicReferenceFieldUpdater.newUpdater(TransactionalSubscriber.class,
						Subscription.class, "s");

		volatile int wip;
		static final AtomicIntegerFieldUpdater<TransactionalSubscriber> WIP =
				AtomicIntegerFieldUpdater.newUpdater(TransactionalSubscriber.class, "wip");

		TransactionalSubscriber(CoreSubscriber<? super T> actual,
				S resource,
				Function<? super S, ? extends Publisher<?>> commit,
				Function<? super S, ? extends Publisher<?>> rollback,
				boolean rollbackOnCancel) {
			this.actual = actual;
			this.resource = resource;
			this.commit = commit;
			this.rollback = rollback;
			this.rollbackOnCancel = rollbackOnCancel;
		}

		@Override
		public CoreSubscriber<? super T> actual() {
			return this.actual;
		}

		@Nullable
		public Object scanUnsafe(Attr key) {
			if (key == Attr.TERMINATED || key == Attr.CANCELLED) return wip == 1;
			if (key == Attr.PARENT) return s;

			return InnerOperator.super.scanUnsafe(key);
		}

		@Override
		public void request(long l) {
			if (Operators.validate(l)) {
				s.request(l);
			}
		}

		@Override
		public void cancel() {
			if (Operators.terminate(SUBSCRIPTION, this)) {
				try {
					if (rollbackOnCancel) {
						//FIXME better integration of rollback-on-cancel?
						Flux.from(rollback.apply(resource)).subscribe();
					}
					else {
						//FIXME better integration of commit-on-cancel?
						Flux.from(commit.apply(resource)).subscribe();
					}
				}
				catch (Throwable error) {
					LOGGER.warn("Error during transactional cancellation", error);
				}
			}
		}

		@Override
		public void onSubscribe(Subscription s) {
			if (Operators.validate(this.s, s)) {
				this.s = s;
				actual.onSubscribe(this);
			}
		}

		@Override
		public void onNext(T t) {
			actual.onNext(t);
		}

		@Override
		public void onError(Throwable t) {
			Publisher<?> p;

			try {
				p = Objects.requireNonNull(rollback.apply(resource),
						"The rollback returned a null Publisher");
			}
			catch (Throwable e) {
				Throwable _e = Operators.onOperatorError(e, actual.currentContext());
				_e = Exceptions.addSuppressed(_e, t);
				actual.onError(_e);
				return;
			}

			p.subscribe(new RollbackInner(this, t));
		}

		@Override
		public void onComplete() {
			Publisher<?> p;

			try {
				p = Objects.requireNonNull(commit.apply(resource),
						"The commit returned a null Publisher");
			}
			catch (Throwable e) {
				Throwable _e = Operators.onOperatorError(e, actual.currentContext());
				actual.onError(_e);
				return;
			}

			p.subscribe(new CommitInner(this));
		}

		@Override
		public int requestFusion(int requestedMode) {
			return NONE; // always reject, upstream turned out to be non-fuseable after all
		}

		@Override
		public void clear() {
			// ignoring fusion methods
		}

		@Override
		public boolean isEmpty() {
			// ignoring fusion methods
			return true;
		}

		@Override
		@Nullable
		public T poll() {
			return null;
		}

		@Override
		public int size() {
			return 0;
		}
	}

	static final class RollbackInner implements InnerConsumer<Object> {

		final TransactionalSubscriber parent;
		final Throwable rollbackCause;

		RollbackInner(TransactionalSubscriber ts, Throwable rollbackCause) {
			this.parent = ts;
			this.rollbackCause = rollbackCause;
		}

		@Override
		public void onSubscribe(Subscription s) {
			Objects.requireNonNull(s, "Subscription cannot be null")
			       .request(Long.MAX_VALUE);
		}

		@Override
		public void onNext(Object o) {
			//NO-OP
		}

		@Override
		public void onError(Throwable e) {
			RuntimeException rollbackError = new RuntimeException("Transaction rollback failed", e);
			parent.actual.onError(Exceptions.addSuppressed(rollbackError, rollbackCause));
		}

		@Override
		public void onComplete() {
			parent.actual.onError(rollbackCause);
		}

		@Override
		public Object scanUnsafe(Attr key) {
			if (key == Attr.PARENT) return parent;
			if (key == Attr.ACTUAL) return parent.actual;
			if (key == Attr.ERROR) return rollbackCause;

			return null;
		}
	}

	static final class CommitInner implements InnerConsumer<Object> {

		final TransactionalSubscriber parent;

		CommitInner(TransactionalSubscriber ts) {
			this.parent = ts;
		}

		@Override
		public void onSubscribe(Subscription s) {
			Objects.requireNonNull(s, "Subscription cannot be null")
			       .request(Long.MAX_VALUE);
		}

		@Override
		public void onNext(Object o) {
			//NO-OP
		}

		@Override
		public void onError(Throwable e) {
			Throwable e_ = Operators.onOperatorError(e, parent.actual.currentContext());
			Throwable commitError = new RuntimeException("Transaction commit failed", e_);
			parent.actual.onError(commitError);
		}

		@Override
		public void onComplete() {
			parent.actual.onComplete();
		}

		@Override
		public Object scanUnsafe(Attr key) {
			if (key == Attr.PARENT) return parent;
			if (key == Attr.ACTUAL) return parent.actual;

			return null;
		}
	}

//	static final class UsingFuseableSubscriber<T, S>
//			implements InnerOperator<T, T>, QueueSubscription<T> {
//
//		final CoreSubscriber<? super T> actual;
//
//		final Consumer<? super S> resourceCleanup;
//
//		final S resource;
//
//		final boolean eager;
//
//		QueueSubscription<T> s;
//
//		volatile int wip;
//		@SuppressWarnings("rawtypes")
//		static final AtomicIntegerFieldUpdater<UsingFuseableSubscriber> WIP =
//				AtomicIntegerFieldUpdater.newUpdater(UsingFuseableSubscriber.class,
//						"wip");
//
//		int mode;
//
//		UsingFuseableSubscriber(CoreSubscriber<? super T> actual,
//				Consumer<? super S> resourceCleanup,
//				S resource,
//				boolean eager) {
//			this.actual = actual;
//			this.resourceCleanup = resourceCleanup;
//			this.resource = resource;
//			this.eager = eager;
//		}
//
//		@Override
//		@Nullable
//		public Object scanUnsafe(Attr key) {
//			if (key == Attr.TERMINATED || key == Attr.CANCELLED)
//				return wip == 1;
//			if (key == Attr.PARENT) return s;
//
//			return InnerOperator.super.scanUnsafe(key);
//		}
//
//		@Override
//		public CoreSubscriber<? super T> actual() {
//			return actual;
//		}
//
//		@Override
//		public void request(long n) {
//			s.request(n);
//		}
//
//		@Override
//		public void cancel() {
//			if (WIP.compareAndSet(this, 0, 1)) {
//				s.cancel();
//
//				cleanup();
//			}
//		}
//
//		void cleanup() {
//			try {
//				resourceCleanup.accept(resource);
//			}
//			catch (Throwable e) {
//				Operators.onErrorDropped(e, actual.currentContext());
//			}
//		}
//
//		@SuppressWarnings("unchecked")
//		@Override
//		public void onSubscribe(Subscription s) {
//			if (Operators.validate(this.s, s)) {
//				this.s = (QueueSubscription<T>) s;
//
//				actual.onSubscribe(this);
//			}
//		}
//
//		@Override
//		public void onNext(T t) {
//			actual.onNext(t);
//		}
//
//		@Override
//		public void onError(Throwable t) {
//			if (eager && WIP.compareAndSet(this, 0, 1)) {
//				try {
//					resourceCleanup.accept(resource);
//				}
//				catch (Throwable e) {
//					Throwable _e = Operators.onOperatorError(e, actual.currentContext());
//					t = Exceptions.addSuppressed(_e, t);
//				}
//			}
//
//			actual.onError(t);
//
//			if (!eager && WIP.compareAndSet(this, 0, 1)) {
//				cleanup();
//			}
//		}
//
//		@Override
//		public void onComplete() {
//			if (eager && WIP.compareAndSet(this, 0, 1)) {
//				try {
//					resourceCleanup.accept(resource);
//				}
//				catch (Throwable e) {
//					actual.onError(Operators.onOperatorError(e, actual.currentContext()));
//					return;
//				}
//			}
//
//			actual.onComplete();
//
//			if (!eager && WIP.compareAndSet(this, 0, 1)) {
//				cleanup();
//			}
//		}
//
//		@Override
//		public void clear() {
//			s.clear();
//		}
//
//		@Override
//		public boolean isEmpty() {
//			return s.isEmpty();
//		}
//
//		@Override
//		@Nullable
//		public T poll() {
//			T v = s.poll();
//
//			if (v == null && mode == SYNC) {
//				if (WIP.compareAndSet(this, 0, 1)) {
//					resourceCleanup.accept(resource);
//				}
//			}
//			return v;
//		}
//
//		@Override
//		public int requestFusion(int requestedMode) {
//			int m = s.requestFusion(requestedMode);
//			mode = m;
//			return m;
//		}
//
//		@Override
//		public int size() {
//			return s.size();
//		}
//	}
//
//	static final class UsingConditionalSubscriber<T, S>
//			implements ConditionalSubscriber<T>, InnerOperator<T, T>,
//			           QueueSubscription<T> {
//
//		final ConditionalSubscriber<? super T> actual;
//
//		final Consumer<? super S> resourceCleanup;
//
//		final S resource;
//
//		final boolean eager;
//
//		Subscription s;
//
//		volatile int wip;
//		@SuppressWarnings("rawtypes")
//		static final AtomicIntegerFieldUpdater<UsingConditionalSubscriber> WIP =
//				AtomicIntegerFieldUpdater.newUpdater(UsingConditionalSubscriber.class,
//						"wip");
//
//		UsingConditionalSubscriber(ConditionalSubscriber<? super T> actual,
//				Consumer<? super S> resourceCleanup,
//				S resource,
//				boolean eager) {
//			this.actual = actual;
//			this.resourceCleanup = resourceCleanup;
//			this.resource = resource;
//			this.eager = eager;
//		}
//
//		@Override
//		@Nullable
//		public Object scanUnsafe(Attr key) {
//			if (key == Attr.TERMINATED || key == Attr.CANCELLED)
//				return wip == 1;
//			if (key == Attr.PARENT) return s;
//
//			return InnerOperator.super.scanUnsafe(key);
//		}
//
//		@Override
//		public CoreSubscriber<? super T> actual() {
//			return actual;
//		}
//
//		@Override
//		public void request(long n) {
//			s.request(n);
//		}
//
//		@Override
//		public void cancel() {
//			if (WIP.compareAndSet(this, 0, 1)) {
//				s.cancel();
//
//				cleanup();
//			}
//		}
//
//		void cleanup() {
//			try {
//				resourceCleanup.accept(resource);
//			}
//			catch (Throwable e) {
//				Operators.onErrorDropped(e, actual.currentContext());
//			}
//		}
//
//		@Override
//		public void onSubscribe(Subscription s) {
//			if (Operators.validate(this.s, s)) {
//				this.s = s;
//
//				actual.onSubscribe(this);
//			}
//		}
//
//		@Override
//		public void onNext(T t) {
//			actual.onNext(t);
//		}
//
//		@Override
//		public boolean tryOnNext(T t) {
//			return actual.tryOnNext(t);
//		}
//
//		@Override
//		public void onError(Throwable t) {
//			if (eager && WIP.compareAndSet(this, 0, 1)) {
//				try {
//					resourceCleanup.accept(resource);
//				}
//				catch (Throwable e) {
//					Throwable _e = Operators.onOperatorError(e, actual.currentContext());
//					t = Exceptions.addSuppressed(_e, t);
//				}
//			}
//
//			actual.onError(t);
//
//			if (!eager && WIP.compareAndSet(this, 0, 1)) {
//				cleanup();
//			}
//		}
//
//		@Override
//		public void onComplete() {
//			if (eager && WIP.compareAndSet(this, 0, 1)) {
//				try {
//					resourceCleanup.accept(resource);
//				}
//				catch (Throwable e) {
//					actual.onError(Operators.onOperatorError(e, actual.currentContext()));
//					return;
//				}
//			}
//
//			actual.onComplete();
//
//			if (!eager && WIP.compareAndSet(this, 0, 1)) {
//				cleanup();
//			}
//		}
//
//		@Override
//		public int requestFusion(int requestedMode) {
//			return NONE; // always reject, upstream turned out to be non-fuseable after all
//		}
//
//		@Override
//		public void clear() {
//			// ignoring fusion methods
//		}
//
//		@Override
//		public boolean isEmpty() {
//			// ignoring fusion methods
//			return true;
//		}
//
//		@Override
//		@Nullable
//		public T poll() {
//			return null;
//		}
//
//		@Override
//		public int size() {
//			return 0;
//		}
//	}
}
